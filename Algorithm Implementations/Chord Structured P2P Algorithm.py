# By Alexandros Panagiotakopoulos
# alexandrospanag.github.io
# This work is licensed under a Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.

# Date: January 2025

import hashlib # For SHA-1 hash function

class Node: # Node class for the Chord protocol
    def __init__(self, node_id): # Constructor
        self.node_id = node_id # Node ID
        self.successor = self # Successor node
        self.finger_table = [self] * 160  # Assuming 160-bit identifiers

    def find_successor(self, key_id): # Find the successor node responsible for a key
        if self.node_id < key_id <= self.successor.node_id:
            return self.successor # If the key is between the current node and its successor, return the successor
        else:
            node = self.closest_preceding_node(key_id) # Otherwise, find the closest preceding node
            return node.find_successor(key_id) # And recursively ask it to find the successor

    def closest_preceding_node(self, key_id): # Find the closest preceding node for a key
        for i in range(159, -1, -1): # Iterate over the finger table in reverse order
            if self.node_id < self.finger_table[i].node_id < key_id: # If the finger is closer to the key
                return self.finger_table[i] # Return the finger
        return self # Otherwise, return the current node

    def join(self, existing_node): # Join the network
        if existing_node: # If there is an existing node
            self.init_finger_table(existing_node) # Initialize the finger table
            self.update_others() # Update other nodes
        else:
            for i in range(160): # If this is the first node in the network
                self.finger_table[i] = self # Set all fingers to itself
            self.successor = self # Set the successor to itself

    def init_finger_table(self, existing_node): # Initialize the finger table
        self.finger_table[0] = existing_node.find_successor(self.node_id) # Find the successor of the current
        self.successor = self.finger_table[0] # Set the successor to the first finger
        for i in range(159): # Iterate over the finger table
            if self.node_id <= self.finger_table[i].node_id < (self.node_id + 2**i) % 2**160: # If the finger is within the range
                self.finger_table[i + 1] = self.finger_table[i] # Set the next finger to the same node
            else:
                self.finger_table[i + 1] = existing_node.find_successor((self.node_id + 2**(i + 1)) % 2**160) # Otherwise, find the successor

    def update_others(self): # Update other nodes
        for i in range(160): # Iterate over the finger table
            pred = self.find_predecessor((self.node_id - 2**i) % 2**160) # Find the predecessor of the current - 2^i
            pred.update_finger_table(self, i) # Update the finger table of the predecessor

    def find_predecessor(self, key_id): # Find the predecessor of a key
        node = self # Start from the current node
        while not (node.node_id < key_id <= node.successor.node_id): # While the key is not between the current node and its successor
            node = node.closest_preceding_node(key_id) # Move to the closest preceding node
        return node # Return the predecessor

    def update_finger_table(self, s, i): # Update the finger table
        if self.node_id <= s.node_id < self.finger_table[i].node_id: # If the new node is closer to the finger
            self.finger_table[i] = s # Update the finger
            pred = self.find_predecessor(self.node_id) # Find the predecessor
            pred.update_finger_table(s, i) # Recursively update the finger table of the predecessor

    def stabilize(self): # Stabilize the network
        x = self.successor.predecessor # Get the predecessor of the successor
        if self.node_id < x.node_id < self.successor.node_id: # If the predecessor is between the current node and the successor
            self.successor = x # Set the successor to the predecessor
        self.successor.notify(self) # Notify the successor

    def notify(self, node): # Notify the node
        if self.predecessor is None or self.node_id < node.node_id < self.predecessor.node_id: # If the new node is the predecessor
            self.predecessor = node # Set the predecessor

    def fix_fingers(self): # Fix the fingers
        for i in range(160): # Iterate over the finger table
            self.finger_table[i] = self.find_successor((self.node_id + 2**i) % 2**160) # Find the successor of the current + 2^i

def hash_function(key):
    return int(hashlib.sha1(key.encode()).hexdigest(), 16) % 2**160 # SHA-1 hash function

# Example usage
node1 = Node(hash_function("node1")) # Create three nodes
node2 = Node(hash_function("node2")) # With random IDs
node3 = Node(hash_function("node3")) # Generated by the hash function

node1.join(None)  # First node in the ring
node2.join(node1) # Join the nodes
node3.join(node1) # To the network

# Lookup example
key = "my_key" # Lookup key
key_id = hash_function(key) # Hash the key
responsible_node = node1.find_successor(key_id) # Find the responsible node
print(f"Node {responsible_node.node_id} is responsible for key {key_id}") # Print the responsible node